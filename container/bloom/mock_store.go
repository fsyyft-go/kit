// Code generated by MockGen. DO NOT EDIT.
// Source: container/bloom/bloom.go

// Package bloom 提供了布隆过滤器的接口定义和实现。
// 布隆过滤器是一种空间效率很高的概率型数据结构，用于判断一个元素是否在集合中。
// 它通过多个哈希函数将元素映射到位数组中的多个位置，从而实现高效的成员查询。
package bloom

import (
    context "context"
    reflect "reflect"

    gomock "github.com/golang/mock/gomock"
)

// MockBloom 是 Bloom 接口的 mock 实现。
// 用于在测试中模拟布隆过滤器的行为。
type MockBloom struct {
    ctrl     *gomock.Controller
    recorder *MockBloomMockRecorder
}

// MockBloomMockRecorder 是 MockBloom 的调用记录器。
// 用于记录和验证对 MockBloom 的方法调用。
type MockBloomMockRecorder struct {
    mock *MockBloom
}

// NewMockBloom 创建一个新的 MockBloom 实例。
//
// 参数：
//   - ctrl：gomock 控制器实例，用于管理 mock 对象
//
// 返回值：
//   - *MockBloom：新创建的 mock 实例
func NewMockBloom(ctrl *gomock.Controller) *MockBloom {
    mock := &MockBloom{ctrl: ctrl}
    mock.recorder = &MockBloomMockRecorder{mock}
    return mock
}

// EXPECT 返回一个对象，允许调用者指示预期的使用。
//
// 返回值：
//   - *MockBloomMockRecorder：用于设置期望的调用记录器
func (m *MockBloom) EXPECT() *MockBloomMockRecorder {
    return m.recorder
}

// Contain 模拟了 Bloom 接口的 Contain 方法。
// 用于判断指定元素是否可能存在于布隆过滤器中。
//
// 参数：
//   - ctx：上下文对象，用于控制请求的生命周期
//   - value：要判断是否存在的元素值
//
// 返回值：
//   - bool：元素是否可能存在于布隆过滤器中
//   - error：操作过程中发生的错误
func (m *MockBloom) Contain(ctx context.Context, value string) (bool, error) {
    m.ctrl.T.Helper()
    ret := m.ctrl.Call(m, "Contain", ctx, value)
    ret0, _ := ret[0].(bool)
    ret1, _ := ret[1].(error)
    return ret0, ret1
}

// Contain 指示对 Contain 方法的预期调用。
//
// 参数：
//   - ctx：上下文对象
//   - value：要判断的元素值
//
// 返回值：
//   - *gomock.Call：用于设置期望的调用
func (mr *MockBloomMockRecorder) Contain(ctx, value interface{}) *gomock.Call {
    mr.mock.ctrl.T.Helper()
    return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Contain", reflect.TypeOf((*MockBloom)(nil).Contain), ctx, value)
}

// GroupContain 模拟了 Bloom 接口的 GroupContain 方法。
// 用于判断指定分组中是否可能包含指定元素。
//
// 参数：
//   - ctx：上下文对象，用于控制请求的生命周期
//   - group：分组名称，用于区分不同的数据集合
//   - value：要判断是否存在的元素值
//
// 返回值：
//   - bool：元素是否可能存在于指定分组中
//   - error：操作过程中发生的错误
func (m *MockBloom) GroupContain(ctx context.Context, group, value string) (bool, error) {
    m.ctrl.T.Helper()
    ret := m.ctrl.Call(m, "GroupContain", ctx, group, value)
    ret0, _ := ret[0].(bool)
    ret1, _ := ret[1].(error)
    return ret0, ret1
}

// GroupContain 指示对 GroupContain 方法的预期调用。
//
// 参数：
//   - ctx：上下文对象
//   - group：分组名称
//   - value：要判断的元素值
//
// 返回值：
//   - *gomock.Call：用于设置期望的调用
func (mr *MockBloomMockRecorder) GroupContain(ctx, group, value interface{}) *gomock.Call {
    mr.mock.ctrl.T.Helper()
    return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GroupContain", reflect.TypeOf((*MockBloom)(nil).GroupContain), ctx, group, value)
}

// GroupPut 模拟了 Bloom 接口的 GroupPut 方法。
// 用于将指定元素添加到指定分组的布隆过滤器中。
//
// 参数：
//   - ctx：上下文对象，用于控制请求的生命周期
//   - group：分组名称，用于区分不同的数据集合
//   - value：要添加到布隆过滤器中的元素值
//
// 返回值：
//   - error：添加过程中发生的错误
func (m *MockBloom) GroupPut(ctx context.Context, group, value string) error {
    m.ctrl.T.Helper()
    ret := m.ctrl.Call(m, "GroupPut", ctx, group, value)
    ret0, _ := ret[0].(error)
    return ret0
}

// GroupPut 指示对 GroupPut 方法的预期调用。
//
// 参数：
//   - ctx：上下文对象
//   - group：分组名称
//   - value：要添加的元素值
//
// 返回值：
//   - *gomock.Call：用于设置期望的调用
func (mr *MockBloomMockRecorder) GroupPut(ctx, group, value interface{}) *gomock.Call {
    mr.mock.ctrl.T.Helper()
    return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GroupPut", reflect.TypeOf((*MockBloom)(nil).GroupPut), ctx, group, value)
}

// Put 模拟了 Bloom 接口的 Put 方法。
// 用于将指定元素添加到布隆过滤器中。
//
// 参数：
//   - ctx：上下文对象，用于控制请求的生命周期
//   - value：要添加到布隆过滤器中的元素值
//
// 返回值：
//   - error：添加过程中发生的错误
func (m *MockBloom) Put(ctx context.Context, value string) error {
    m.ctrl.T.Helper()
    ret := m.ctrl.Call(m, "Put", ctx, value)
    ret0, _ := ret[0].(error)
    return ret0
}

// Put 指示对 Put 方法的预期调用。
//
// 参数：
//   - ctx：上下文对象
//   - value：要添加的元素值
//
// 返回值：
//   - *gomock.Call：用于设置期望的调用
func (mr *MockBloomMockRecorder) Put(ctx, value interface{}) *gomock.Call {
    mr.mock.ctrl.T.Helper()
    return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Put", reflect.TypeOf((*MockBloom)(nil).Put), ctx, value)
}

// MockStore 是 Store 接口的 mock 实现。
// 用于在测试中模拟布隆过滤器底层数据存储的行为。
type MockStore struct {
    ctrl     *gomock.Controller
    recorder *MockStoreMockRecorder
}

// MockStoreMockRecorder 是 MockStore 的调用记录器。
// 用于记录和验证对 MockStore 的方法调用。
type MockStoreMockRecorder struct {
    mock *MockStore
}

// NewMockStore 创建一个新的 MockStore 实例。
//
// 参数：
//   - ctrl：gomock 控制器实例，用于管理 mock 对象
//
// 返回值：
//   - *MockStore：新创建的 mock 实例
func NewMockStore(ctrl *gomock.Controller) *MockStore {
    mock := &MockStore{ctrl: ctrl}
    mock.recorder = &MockStoreMockRecorder{mock}
    return mock
}

// EXPECT 返回一个对象，允许调用者指示预期的使用。
//
// 返回值：
//   - *MockStoreMockRecorder：用于设置期望的调用记录器
func (m *MockStore) EXPECT() *MockStoreMockRecorder {
    return m.recorder
}

// Add 模拟了 Store 接口的 Add 方法。
// 用于将一组 hash 值添加到指定 key 对应的存储中。
//
// 参数：
//   - ctx：上下文对象，用于控制请求的生命周期
//   - key：存储键名
//   - hash：要添加的哈希值列表
//
// 返回值：
//   - error：添加过程中发生的错误
func (m *MockStore) Add(ctx context.Context, key string, hash []uint64) error {
    m.ctrl.T.Helper()
    ret := m.ctrl.Call(m, "Add", ctx, key, hash)
    ret0, _ := ret[0].(error)
    return ret0
}

// Add 指示对 Add 方法的预期调用。
//
// 参数：
//   - ctx：上下文对象
//   - key：存储键名
//   - hash：要添加的哈希值列表
//
// 返回值：
//   - *gomock.Call：用于设置期望的调用
func (mr *MockStoreMockRecorder) Add(ctx, key, hash interface{}) *gomock.Call {
    mr.mock.ctrl.T.Helper()
    return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockStore)(nil).Add), ctx, key, hash)
}

// Exist 模拟了 Store 接口的 Exist 方法。
// 用于判断指定 key 对应的所有 hash 值是否都已存在。
//
// 参数：
//   - ctx：上下文对象，用于控制请求的生命周期
//   - key：存储键名
//   - hash：要判断的哈希值列表
//
// 返回值：
//   - bool：所有哈希值是否都已存在
//   - error：查询过程中发生的错误
func (m *MockStore) Exist(ctx context.Context, key string, hash []uint64) (bool, error) {
    m.ctrl.T.Helper()
    ret := m.ctrl.Call(m, "Exist", ctx, key, hash)
    ret0, _ := ret[0].(bool)
    ret1, _ := ret[1].(error)
    return ret0, ret1
}

// Exist 指示对 Exist 方法的预期调用。
//
// 参数：
//   - ctx：上下文对象
//   - key：存储键名
//   - hash：要判断的哈希值列表
//
// 返回值：
//   - *gomock.Call：用于设置期望的调用
func (mr *MockStoreMockRecorder) Exist(ctx, key, hash interface{}) *gomock.Call {
    mr.mock.ctrl.T.Helper()
    return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exist", reflect.TypeOf((*MockStore)(nil).Exist), ctx, key, hash)
}