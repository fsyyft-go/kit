// Code generated by MockGen. DO NOT EDIT.
// Source: container/bloom/bloom.go

// Package bloom is a generated GoMock package.
package bloom

import (
	context "context"
	reflect "reflect"

	gomock "github.com/golang/mock/gomock"
)

// MockBloom is a mock of Bloom interface.
type MockBloom struct {
	ctrl     *gomock.Controller
	recorder *MockBloomMockRecorder
}

// MockBloomMockRecorder is the mock recorder for MockBloom.
type MockBloomMockRecorder struct {
	mock *MockBloom
}

// NewMockBloom creates a new mock instance.
func NewMockBloom(ctrl *gomock.Controller) *MockBloom {
	mock := &MockBloom{ctrl: ctrl}
	mock.recorder = &MockBloomMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockBloom) EXPECT() *MockBloomMockRecorder {
	return m.recorder
}

// Contain mocks base method.
func (m *MockBloom) Contain(ctx context.Context, value string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Contain", ctx, value)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Contain indicates an expected call of Contain.
func (mr *MockBloomMockRecorder) Contain(ctx, value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Contain", reflect.TypeOf((*MockBloom)(nil).Contain), ctx, value)
}

// GroupContain mocks base method.
func (m *MockBloom) GroupContain(ctx context.Context, group, value string) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GroupContain", ctx, group, value)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// GroupContain indicates an expected call of GroupContain.
func (mr *MockBloomMockRecorder) GroupContain(ctx, group, value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GroupContain", reflect.TypeOf((*MockBloom)(nil).GroupContain), ctx, group, value)
}

// GroupPut mocks base method.
func (m *MockBloom) GroupPut(ctx context.Context, group, value string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "GroupPut", ctx, group, value)
	ret0, _ := ret[0].(error)
	return ret0
}

// GroupPut indicates an expected call of GroupPut.
func (mr *MockBloomMockRecorder) GroupPut(ctx, group, value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "GroupPut", reflect.TypeOf((*MockBloom)(nil).GroupPut), ctx, group, value)
}

// Put mocks base method.
func (m *MockBloom) Put(ctx context.Context, value string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Put", ctx, value)
	ret0, _ := ret[0].(error)
	return ret0
}

// Put indicates an expected call of Put.
func (mr *MockBloomMockRecorder) Put(ctx, value interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Put", reflect.TypeOf((*MockBloom)(nil).Put), ctx, value)
}

// MockStore is a mock of Store interface.
type MockStore struct {
	ctrl     *gomock.Controller
	recorder *MockStoreMockRecorder
}

// MockStoreMockRecorder is the mock recorder for MockStore.
type MockStoreMockRecorder struct {
	mock *MockStore
}

// NewMockStore creates a new mock instance.
func NewMockStore(ctrl *gomock.Controller) *MockStore {
	mock := &MockStore{ctrl: ctrl}
	mock.recorder = &MockStoreMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockStore) EXPECT() *MockStoreMockRecorder {
	return m.recorder
}

// Add mocks base method.
func (m *MockStore) Add(ctx context.Context, key string, hash []uint64) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Add", ctx, key, hash)
	ret0, _ := ret[0].(error)
	return ret0
}

// Add indicates an expected call of Add.
func (mr *MockStoreMockRecorder) Add(ctx, key, hash interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Add", reflect.TypeOf((*MockStore)(nil).Add), ctx, key, hash)
}

// Exist mocks base method.
func (m *MockStore) Exist(ctx context.Context, key string, hash []uint64) (bool, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "Exist", ctx, key, hash)
	ret0, _ := ret[0].(bool)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// Exist indicates an expected call of Exist.
func (mr *MockStoreMockRecorder) Exist(ctx, key, hash interface{}) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "Exist", reflect.TypeOf((*MockStore)(nil).Exist), ctx, key, hash)
}
